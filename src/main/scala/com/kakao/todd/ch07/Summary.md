# Parallelism

현 세대의 컴퓨터는 multi-core 이다. 그러나 병렬로 실행하는 프로그램을 작성하는 일은 매우 어렵다.
전통적으로 Thread 사이에 통신에 쓰이는 메커니즘은 추론 분석하기 어렵기로 악명이 높다. 
그러다보니 Race condition(경쟁 조건) 이나 Dead lock(교착)이 발생하기 슆고 Scalability 를 확보하기도 상당히 까다롭다.

# Library Design Example

착안 - 리스트의 합을 구하는데 계산을 병렬적으로 수행할 수 있는 라이브러리를 설계해보자.
라이브러리 설계의 과정은 착안한 아이디어를 refining 하는 과정을 거쳐서 원하는 기능을 가능하게 하는 방식으로 진행

[Sample01_ParSum](Sample01_ParSum.scala)

# Algebra of Function 

이전에 보았듯이, 일단 원하는 연산의 형식만 작성한 후 그 형식을 따라가다 보면 구현에 도달하는 경우가 많다.
이런식으로 코딩할 때에는 구체적인 문제 영역을 완전히 잊어버리고 형식들이 잘 맞아떨어지게 하는 데에만 집중할 수 있다.
이는 속임수가 아니라 대수 방정식을 단순화할 때 하는 추론과 비슷한 자연스러운 추론 방식이다.

API를 하나의 대수(algebra), 즉 일단의 법칙(law) 또는 참으로 가정하는 속성들을 가진 추상적인 연산 집합으로 간주하고, 그 대수의 정의된 게임 규칙에 따라 그냥 형식적으로 
기호를 조작하면서 문제를 풀어간다. 

```
identity

항등식, 양변의 두 표현식이 상등 또는 동치를 뜻하는 수학적 의미

```

아래와 같이 항등식을 이용해 단순화 혹은 복잡화를 할 수 있다. 

map(unit(1))(_ + 1) == unit(2)
map(unit(x))(f) == unit(f(x))
map(unit(x))(id) == unit(id(x)) // id는 아무일도 안함
map(unit(x))(id) == unit(x)
map(y)(id) == y

fork는 더욱 간단하다. fork는 x와 돌일한 일을 수행하되 멀티 스레드에서 동작한다.

fork(x) == x




